[] Структура описания классов: переписать все классы в соответствии с этим планом!
    -приватные поля
    -публичные методы:
        конструкторы по умолчанию
        перемещающие конструкторы
        деструктор
        операторы присваивания
        прочие операторы
        остальные методы
    защищенные методы
    приватные методы
[x] Геттеры к полям класса -> имя_поля()
      Сеттеры -> set_поле_класса()
[x] Переименовать базовые классы: base_class_имякласа.h
[x] Поля класса всегда заканчиваются нижним подчеркиванием
(исправить в уже созданных классах)
[ ] все методы класса, вовзращающие ссылки лучше lr-аннотировать
[x] Ответственность за удаление потомков возложена на классы-наследники Widget, а удаление связи с родителем на класс Widget
[ ] В конструкторе выполняется минимальный набор действий, необходимых для инициализации,
установление родственных связей происходит в отдельном методе инициализации

+1.Реализовать класс Widget, итератор внутренний чтобы можно было
итерироваться по потомкам Widget. Потомки смогут переопределять
операции обхода потомков. 
->2.Сделать несколько классов-кадров в UI. Каждый класс описывает определенный внешний вид, содержит свой набор
виджетов: (до 14.09)
+окно Приветствия:
-----------------------------------------------------------
      ██████╗  █████╗ ████████╗
      ██╔══██╗██╔══██╗╚══██╔══╝
      ██████╔╝███████║   ██║
      ██╔══██╗██╔══██║   ██║
      ██║  ██║██║  ██║   ██║
      ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝(только тут будет название программы и автор)

           Kanban CLI
       Task Management, Fast.

         Press ENTER to start
         Press S for Settings
         Press Q to quit
-----------------------------------------------------------


+окно Настроек
-----------------------------------------------------------
    SETTINGS

 -> Theme:           [Dark    ●] [Light ○]
    Auto-save:       [Enabled ●] [Disabled ○]
    Key mode:        [Vim     ●] [Emacs ○] [Classic ○]
    Show estimates:  [Yes     ○] [No    ●]
    Startup screen:  [Board   ●] [Welcome ○]

    [ Save & Exit ]   [ Cancel ]
           ●               ○

 Arrows: navigate │ Space/Enter: toggle │ Tab: switch buttons │ Esc: cancel
-----------------------------------------------------------


+окно Главный экран
-----------------------------------------------------------
KanTask — Личный трекер задач               Прогресс: [████░░░░░░] 40% (2/5)

В ПЛАНЕ               В РАБОТЕ              ГОТОВО
• (!) Настроить CI    • (~) Исправить баг   • (•) Прочитать доку
• (~) Написать тесты                        • (!) Настроить CI/CD
• (•) Составить ТЗ

────────────────────────────────────────────────────────────
ЗАДАЧА: (!) Настроить CI
Срок: 07.11        Теги: #build #ci       Статус: В ПЛАНЕ
Описание: Настроить пайплайн сборки и тестов в GitLab CI.

F1: Справка  F2: Новая задача  F3: Переместить  F10: Меню    ←→: колонка  ↑↓: задача  Enter: действия
-----------------------------------------------------------
...
2.1 +Реализовать систему координат: координаты для отрисовки должны подаваться в процентах, виджеты сами адаптируются
    +Решить вопрос добавления потомков: добавлять через конструктор или явно вызывать метод или комбинированный подход
    +обернуть итератор в умный указатель 
    +каждый виджет имеет уникальный ID: позволяет идентифицировать виджеты, определять операции сравнения, доступен поиск в ассоциативных контейнерах
    ~~-если виджет cdk не принимает на вход размеры, то класс cui все равно принимает ширину/высоту, но эти значения идут на ограничения сообщения в виджете cdk: то есть если указано что ширина 50% это значит что Message нужно ограничить так, чтобы виджет с этим сообщением занимал не больше 50% от площади родиетльского окна~~
    +задавать координаты виджета тоже в процентах от всей площади экрана
    +сделать виджет, который реализует просто обводку по своему периметру - использовать в WidgetBox
    +каждый класс-коллекция виджетов должен создаваться через фабричную функцию, чтобы корректно устанавливать родственные связи
    -Виджет принимает размеры и тип поверхности, при этом по умолчанию выставлена относительная поверхность -> передавать не указатель поверхности, а enum на поверхность
    
3.Собрать класс Приложение в UI - оно содержит ссылку на активное окно, дает дает доступ к своему содержимому
4.Реализовать взаимодействие с наполнением каждого окна:
-класс Приложение обрабатывает действие пользователя

^^^^^VERSION 0.5.0^^^^^